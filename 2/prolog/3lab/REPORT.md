#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Диёров Д.У.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Задачи искуственного интелекта могут решаться методом поиска в пространстве состояний. Prolog удобный для этого язык так как с помощью него можно удобно задавать состояния в виде предикатов. Prolog автоматически проводит поиск по возможным значениям переменных и применяет правила для унификации, что освобождает разработчика от необходимости явно указывать порядок итераций.


## Задание

Железнодорожный сортировочный узел устроен так, как показано на
рисунке. На левой стороне собрано некоторое число вагонов двух типов
(черные и белые), обоих типов по n штук., в произвольном порядке
Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными
операциями (слева в тупик, из тупика направо, слева направо, минуя
тупик), собрать вагоны на левой стороне, так, чтобы типы чередовались.
Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения
Изначально для каждого решения в глубину, в ширину и поиска с итеративным погружением формируется ожидаемый результат конечного состояния решения (Cond, который по сути является целью), и когда запускается основной предикат он проверяет являтся ли нынешнее состояние нужным нам. Если да, то печатает решение. Так как вагоны могут начинаться с белого либо с черного, основых предиката для каждого метода поиска два. Предикат `right_end` нужен как раз для того чтобы сформировать необходимый результат.
```prolog
right_end([], [], _).
right_end([_ | [_ | Tail]], [w|[b|End]], w) :-
    right_end(Tail, End, w).
right_end([_ | [_ | Tail]], [b|[w|End]], b) :-
    right_end(Tail, End, b).
```


## Результаты

Приведите результаты работы программы: найденные пути, время, затраченное на поиск тем или иным алгоритмом, длину найденного первым пути. Используйте таблицы,
если необходимо.


| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |  9                             | 0,0007         |
| В ширину        |  6                             |  0,08         |
| В глубину с итеративным погружением              |  6                             |  0,004         |

## Выводы

Данная лаборатнорная работа научила меня решению задач искусственного интеллекта с помощью поиска в пространстве состояний на языке Prolog. А также формировать и проверять все возможные решения задачи.
Для наиболее быстрого решения лучше использовать поиск в глубину, но если необходимо решение, которое является максимально эффективным, то лучше подойдет поиск в ширину, однако для поиска в ширину необходимо выделять больше памяти, что при больших данных может привести к сбоям программы.
Самым оптимальным по времени в моем случае оказался поиск в глубину, однако он выдал не самый кратчайший путь. Изначально эффективное решение нашли поиск в ширину и в глубину с итеративным погружением. 



